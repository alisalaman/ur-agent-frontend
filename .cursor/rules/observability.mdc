---
description: Frontend observability, monitoring, and analytics guidelines for GOV.UK applications
globs: ["**/*.ts", "**/*.tsx", "**/*.js", "**/*.jsx"]
tags: ["observability", "monitoring", "analytics", "frontend", "govuk"]
priority: 9
alwaysApply: false
---

# Frontend Observability & Monitoring

## Context
Comprehensive observability strategies for frontend applications including user analytics, performance monitoring, error tracking, and GOV.UK analytics integration to ensure optimal user experience and system health.

## Guidelines

### Frontend Analytics & Tracking
- **Implement GOV.UK Analytics** for user behaviour tracking
- **Track Core Web Vitals** (LCP, FID, CLS) for performance monitoring
- **Use structured event tracking** with consistent naming conventions
- **Avoid tracking sensitive information** (PII, personal data)
- **Include contextual metadata** for effective analysis and debugging

### Performance Monitoring
- **Monitor Core Web Vitals** (Largest Contentful Paint, First Input Delay, Cumulative Layout Shift)
- **Track page load times** and user interaction metrics
- **Monitor bundle size** and loading performance
- **Implement Real User Monitoring** (RUM) for production insights
- **Track conversion funnels** and user journey analytics

### Error Tracking & Debugging
- **Implement client-side error tracking** with proper context
- **Use error boundaries** to capture React component errors
- **Track JavaScript errors** and unhandled promise rejections
- **Monitor network failures** and API error rates
- **Include user context** in error reports for debugging

### User Experience Monitoring
- **Track user interactions** and engagement metrics
- **Monitor form completion rates** and validation errors
- **Track accessibility compliance** and assistive technology usage
- **Monitor cross-browser compatibility** and device performance
- **Implement A/B testing** and feature flag analytics

## Examples

### ✅ Good Frontend Analytics Implementation
```typescript
interface AnalyticsEvent {
  event: string;
  category: string;
  action: string;
  label?: string;
  value?: number;
  customDimensions?: Record<string, any>;
  timestamp: number;
  sessionId: string;
  userId?: string;
}

class AnalyticsService {
  private sessionId: string;
  private userId?: string;
  private sensitiveKeys = new Set([
    'password', 'token', 'secret', 'key', 'auth',
    'creditCard', 'ssn', 'email', 'phone'
  ]);

  constructor() {
    this.sessionId = this.generateSessionId();
  }

  private generateSessionId(): string {
    return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  setUserId(userId: string) {
    this.userId = userId;
  }

  track(event: string, category: string, action: string, label?: string, value?: number) {
    const analyticsEvent: AnalyticsEvent = {
      event,
      category,
      action,
      label,
      value,
      timestamp: Date.now(),
      sessionId: this.sessionId,
      userId: this.userId,
    };

    // Send to GOV.UK Analytics
    this.sendToGovukAnalytics(analyticsEvent);
    
    // Send to custom analytics if needed
    this.sendToCustomAnalytics(analyticsEvent);
  }

  private sendToGovukAnalytics(event: AnalyticsEvent) {
    // GOV.UK Analytics implementation
    if (typeof window !== 'undefined' && (window as any).gtag) {
      (window as any).gtag('event', event.action, {
        event_category: event.category,
        event_label: event.label,
        value: event.value,
        custom_map: event.customDimensions,
      });
    }
  }

  private sendToCustomAnalytics(event: AnalyticsEvent) {
    // Custom analytics implementation
    console.log('Analytics Event:', this.sanitizeEvent(event));
  }

  private sanitizeEvent(event: AnalyticsEvent): AnalyticsEvent {
    const sanitized = { ...event };
    
    if (sanitized.customDimensions) {
      sanitized.customDimensions = this.sanitizeObject(sanitized.customDimensions);
    }
    
    return sanitized;
  }

  private sanitizeObject(obj: Record<string, any>): Record<string, any> {
    const sanitized: Record<string, any> = {};
    
    for (const [key, value] of Object.entries(obj)) {
      if (this.sensitiveKeys.has(key.toLowerCase())) {
        sanitized[key] = '[REDACTED]';
      } else if (typeof value === 'object' && value !== null) {
        sanitized[key] = this.sanitizeObject(value);
      } else {
        sanitized[key] = value;
      }
    }
    
    return sanitized;
  }
}

// Global analytics instance
export const analytics = new AnalyticsService();

class LoggingService:
    """Service for consistent application logging."""

    @staticmethod
    def set_correlation_context(
        correlation_id: Optional[str] = None,
        user_id: Optional[str] = None,
        request_id: Optional[str] = None
    ) -> str:
        """Set correlation context for the current execution."""
        if not correlation_id:
            correlation_id = str(uuid4())

        correlation_id_var.set(correlation_id)
        if user_id:
            user_id_var.set(user_id)
        if request_id:
            request_id_var.set(request_id)

        return correlation_id

    @staticmethod
    def clear_correlation_context() -> None:
        """Clear correlation context."""
        correlation_id_var.set(None)
        user_id_var.set(None)
        request_id_var.set(None)

    @staticmethod
    def log_api_request(
        method: str,
        path: str,
        status_code: int,
        duration_ms: float,
        request_size: Optional[int] = None,
        response_size: Optional[int] = None
    ) -> None:
        """Log API request with standardised format."""
        logger.info(
            "HTTP request completed",
            method=method,
            path=path,
            status_code=status_code,
            duration_ms=duration_ms,
            request_size=request_size,
            response_size=response_size,
            event_type="http_request"
        )

    @staticmethod
    def log_business_event(
        event_type: str,
        entity_type: str,
        entity_id: str,
        action: str,
        metadata: Optional[Dict[str, Any]] = None
    ) -> None:
        """Log business events for analytics."""
        logger.info(
            f"{entity_type.title()} {action}",
            event_type="business_event",
            business_event_type=event_type,
            entity_type=entity_type,
            entity_id=entity_id,
            action=action,
            metadata=metadata or {}
        )

    @staticmethod
    def log_external_service_call(
        service: str,
        operation: str,
        success: bool,
        duration_ms: float,
        status_code: Optional[int] = None,
        error: Optional[str] = None
    ) -> None:
        """Log external service calls."""
        level = "info" if success else "warning"

        getattr(logger, level)(
            f"External service call: {service}.{operation}",
            event_type="external_service_call",
            service=service,
            operation=operation,
            success=success,
            duration_ms=duration_ms,
            status_code=status_code,
            error=error
        )

# Usage example
async def example_service_method(user_id: str, data: Dict[str, Any]):
    """Example service method with proper logging."""

    # Set correlation context
    correlation_id = LoggingService.set_correlation_context(
        user_id=user_id,
        request_id=str(uuid4())
    )

    try:
        logger.info(
            "Processing user request",
            operation="process_user_data",
            data_size=len(str(data))
        )

        # Simulate processing
        start_time = time.time()

        # External service call
        try:
            result = await external_api_call(data)
            duration = (time.time() - start_time) * 1000

            LoggingService.log_external_service_call(
                service="external_api",
                operation="process_data",
                success=True,
                duration_ms=duration,
                status_code=200
            )

        except Exception as e:
            duration = (time.time() - start_time) * 1000

            LoggingService.log_external_service_call(
                service="external_api",
                operation="process_data",
                success=False,
                duration_ms=duration,
                error=str(e)
            )
            raise

        # Log business event
        LoggingService.log_business_event(
            event_type="data_processing",
            entity_type="user",
            entity_id=user_id,
            action="processed",
            metadata={"result_size": len(str(result))}
        )

        logger.info(
            "User request processed successfully",
            operation="process_user_data",
            processing_time_ms=(time.time() - start_time) * 1000
        )

        return result

    except Exception as e:
        logger.error(
            "Failed to process user request",
            operation="process_user_data",
            error=str(e),
            error_type=type(e).__name__,
            exc_info=True
        )
        raise

    finally:
        LoggingService.clear_correlation_context()
```

### ✅ Good Metrics Implementation
```python
import time
from typing import Dict, Any, Optional, Callable
from functools import wraps
from prometheus_client import (
    Counter, Histogram, Gauge, Summary, start_http_server
)
import asyncio

class ApplicationMetrics:
    """Centralised application metrics."""

    def __init__(self, service_name: str):
        self.service_name = service_name

        # HTTP metrics
        self.http_requests_total = Counter(
            'http_requests_total',
            'Total HTTP requests',
            ['method', 'endpoint', 'status']
        )

        self.http_request_duration = Histogram(
            'http_request_duration_seconds',
            'HTTP request duration',
            ['method', 'endpoint'],
            buckets=[0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1.0, 2.5, 5.0, 10.0]
        )

        # Business metrics
        self.business_operations_total = Counter(
            'business_operations_total',
            'Total business operations',
            ['operation', 'status']
        )

        self.business_operation_duration = Histogram(
            'business_operation_duration_seconds',
            'Business operation duration',
            ['operation']
        )

        # External service metrics
        self.external_service_calls_total = Counter(
            'external_service_calls_total',
            'Total external service calls',
            ['service', 'operation', 'status']
        )

        self.external_service_duration = Histogram(
            'external_service_duration_seconds',
            'External service call duration',
            ['service', 'operation']
        )

        # System metrics
        self.active_connections = Gauge(
            'active_connections',
            'Number of active connections'
        )

        self.cache_operations_total = Counter(
            'cache_operations_total',
            'Total cache operations',
            ['operation', 'result']  # hit, miss, error
        )

        # Circuit breaker metrics
        self.circuit_breaker_state = Gauge(
            'circuit_breaker_state',
            'Circuit breaker state (0=closed, 1=open, 2=half_open)',
            ['name']
        )

        # Database metrics
        self.database_connections_active = Gauge(
            'database_connections_active',
            'Active database connections'
        )

        self.database_query_duration = Histogram(
            'database_query_duration_seconds',
            'Database query duration',
            ['operation']
        )

    def track_http_request(self, method: str, endpoint: str, status: int, duration: float):
        """Track HTTP request metrics."""
        self.http_requests_total.labels(
            method=method,
            endpoint=endpoint,
            status=str(status)
        ).inc()

        self.http_request_duration.labels(
            method=method,
            endpoint=endpoint
        ).observe(duration)

    def track_business_operation(self, operation: str, status: str, duration: float):
        """Track business operation metrics."""
        self.business_operations_total.labels(
            operation=operation,
            status=status
        ).inc()

        self.business_operation_duration.labels(operation=operation).observe(duration)

    def track_external_service_call(
        self,
        service: str,
        operation: str,
        status: str,
        duration: float
    ):
        """Track external service call metrics."""
        self.external_service_calls_total.labels(
            service=service,
            operation=operation,
            status=status
        ).inc()

        self.external_service_duration.labels(
            service=service,
            operation=operation
        ).observe(duration)

# Global metrics instance
metrics = ApplicationMetrics("ai_agent_service")

def track_duration(metric_func: Callable):
    """Decorator to track operation duration."""
    def decorator(func):
        @wraps(func)
        async def async_wrapper(*args, **kwargs):
            start_time = time.time()
            try:
                result = await func(*args, **kwargs)
                duration = time.time() - start_time
                metric_func("success", duration)
                return result
            except Exception as e:
                duration = time.time() - start_time
                metric_func("error", duration)
                raise

        @wraps(func)
        def sync_wrapper(*args, **kwargs):
            start_time = time.time()
            try:
                result = func(*args, **kwargs)
                duration = time.time() - start_time
                metric_func("success", duration)
                return result
            except Exception as e:
                duration = time.time() - start_time
                metric_func("error", duration)
                raise

        return async_wrapper if asyncio.iscoroutinefunction(func) else sync_wrapper
    return decorator

# Usage examples
@track_duration(lambda status, duration: metrics.track_business_operation("user_creation", status, duration))
async def create_user(user_data: Dict[str, Any]) -> Dict[str, Any]:
    """Create user with metrics tracking."""
    # Business logic here
    pass

class MetricsMiddleware:
    """FastAPI middleware for automatic metrics collection."""

    def __init__(self, app, metrics_instance: ApplicationMetrics):
        self.app = app
        self.metrics = metrics_instance

    async def __call__(self, scope, receive, send):
        if scope["type"] != "http":
            await self.app(scope, receive, send)
            return

        start_time = time.time()
        status_code = 500  # Default to error

        async def send_wrapper(message):
            nonlocal status_code
            if message["type"] == "http.response.start":
                status_code = message["status"]
            await send(message)

        try:
            await self.app(scope, receive, send_wrapper)
        finally:
            duration = time.time() - start_time
            method = scope["method"]
            path = scope["path"]

            self.metrics.track_http_request(method, path, status_code, duration)
```

### ✅ Good Health Checks
```python
from typing import Dict, Any, List, Optional
from enum import Enum
import asyncio
import time
from dataclasses import dataclass

class HealthStatus(Enum):
    """Health check status levels."""
    HEALTHY = "healthy"
    DEGRADED = "degraded"
    UNHEALTHY = "unhealthy"

@dataclass
class HealthCheckResult:
    """Result of a health check."""
    name: str
    status: HealthStatus
    response_time_ms: float
    message: Optional[str] = None
    details: Optional[Dict[str, Any]] = None

class HealthChecker:
    """Comprehensive health checking system."""

    def __init__(self):
        self.checks: Dict[str, Callable] = {}
        self.check_results: Dict[str, HealthCheckResult] = {}
        self.last_check_time: Optional[float] = None

    def register_check(self, name: str, check_func: Callable):
        """Register a health check function."""
        self.checks[name] = check_func

    async def run_check(self, name: str) -> HealthCheckResult:
        """Run a single health check."""
        if name not in self.checks:
            return HealthCheckResult(
                name=name,
                status=HealthStatus.UNHEALTHY,
                response_time_ms=0,
                message=f"Check '{name}' not found"
            )

        start_time = time.time()
        try:
            check_func = self.checks[name]

            # Run check with timeout
            result = await asyncio.wait_for(check_func(), timeout=10.0)

            response_time_ms = (time.time() - start_time) * 1000

            if isinstance(result, HealthCheckResult):
                result.response_time_ms = response_time_ms
                return result
            elif isinstance(result, bool):
                return HealthCheckResult(
                    name=name,
                    status=HealthStatus.HEALTHY if result else HealthStatus.UNHEALTHY,
                    response_time_ms=response_time_ms
                )
            else:
                return HealthCheckResult(
                    name=name,
                    status=HealthStatus.HEALTHY,
                    response_time_ms=response_time_ms,
                    details=result if isinstance(result, dict) else None
                )

        except asyncio.TimeoutError:
            response_time_ms = (time.time() - start_time) * 1000
            return HealthCheckResult(
                name=name,
                status=HealthStatus.UNHEALTHY,
                response_time_ms=response_time_ms,
                message="Health check timed out"
            )
        except Exception as e:
            response_time_ms = (time.time() - start_time) * 1000
            return HealthCheckResult(
                name=name,
                status=HealthStatus.UNHEALTHY,
                response_time_ms=response_time_ms,
                message=str(e)
            )

    async def run_all_checks(self) -> Dict[str, HealthCheckResult]:
        """Run all registered health checks."""
        tasks = [
            self.run_check(name) for name in self.checks.keys()
        ]

        results = await asyncio.gather(*tasks, return_exceptions=True)

        self.check_results = {}
        for result in results:
            if isinstance(result, HealthCheckResult):
                self.check_results[result.name] = result
            elif isinstance(result, Exception):
                # This shouldn't happen with our error handling, but just in case
                self.check_results["unknown"] = HealthCheckResult(
                    name="unknown",
                    status=HealthStatus.UNHEALTHY,
                    response_time_ms=0,
                    message=str(result)
                )

        self.last_check_time = time.time()
        return self.check_results

    def get_overall_status(self) -> HealthStatus:
        """Get overall system health status."""
        if not self.check_results:
            return HealthStatus.UNHEALTHY

        statuses = [result.status for result in self.check_results.values()]

        if all(status == HealthStatus.HEALTHY for status in statuses):
            return HealthStatus.HEALTHY
        elif any(status == HealthStatus.UNHEALTHY for status in statuses):
            return HealthStatus.UNHEALTHY
        else:
            return HealthStatus.DEGRADED

    def get_health_summary(self) -> Dict[str, Any]:
        """Get comprehensive health summary."""
        overall_status = self.get_overall_status()

        return {
            "status": overall_status.value,
            "timestamp": self.last_check_time,
            "checks": {
                name: {
                    "status": result.status.value,
                    "response_time_ms": result.response_time_ms,
                    "message": result.message,
                    "details": result.details
                }
                for name, result in self.check_results.items()
            },
            "summary": {
                "total_checks": len(self.check_results),
                "healthy_checks": len([
                    r for r in self.check_results.values()
                    if r.status == HealthStatus.HEALTHY
                ]),
                "unhealthy_checks": len([
                    r for r in self.check_results.values()
                    if r.status == HealthStatus.UNHEALTHY
                ])
            }
        }

# Specific health check implementations
async def database_health_check() -> HealthCheckResult:
    """Check database connectivity and performance."""
    try:
        start_time = time.time()

        # Simple connectivity test
        async with db_pool.acquire() as conn:
            await conn.execute("SELECT 1")

        query_time = (time.time() - start_time) * 1000

        # Check connection pool health
        pool_size = db_pool.get_size()
        idle_connections = db_pool.get_idle_size()

        if query_time > 1000:  # > 1 second
            status = HealthStatus.DEGRADED
            message = f"Database responding slowly ({query_time:.2f}ms)"
        elif idle_connections < 2:  # Low on connections
            status = HealthStatus.DEGRADED
            message = f"Database connection pool under pressure ({idle_connections} idle)"
        else:
            status = HealthStatus.HEALTHY
            message = None

        return HealthCheckResult(
            name="database",
            status=status,
            response_time_ms=query_time,
            message=message,
            details={
                "pool_size": pool_size,
                "idle_connections": idle_connections,
                "query_time_ms": query_time
            }
        )

    except Exception as e:
        return HealthCheckResult(
            name="database",
            status=HealthStatus.UNHEALTHY,
            response_time_ms=0,
            message=f"Database connection failed: {str(e)}"
        )

async def redis_health_check() -> HealthCheckResult:
    """Check Redis connectivity and performance."""
    try:
        start_time = time.time()

        # Test basic operations
        await redis_client.ping()
        await redis_client.set("health_check", "test", ex=60)
        value = await redis_client.get("health_check")

        response_time = (time.time() - start_time) * 1000

        if value != b"test":
            return HealthCheckResult(
                name="redis",
                status=HealthStatus.UNHEALTHY,
                response_time_ms=response_time,
                message="Redis read/write test failed"
            )

        # Check memory usage
        info = await redis_client.info("memory")
        memory_usage = info.get("used_memory_rss", 0)
        max_memory = info.get("maxmemory", 0)

        status = HealthStatus.HEALTHY
        message = None

        if max_memory > 0 and memory_usage / max_memory > 0.9:
            status = HealthStatus.DEGRADED
            message = f"Redis memory usage high ({memory_usage / max_memory:.1%})"
        elif response_time > 100:  # > 100ms
            status = HealthStatus.DEGRADED
            message = f"Redis responding slowly ({response_time:.2f}ms)"

        return HealthCheckResult(
            name="redis",
            status=status,
            response_time_ms=response_time,
            message=message,
            details={
                "memory_usage_bytes": memory_usage,
                "max_memory_bytes": max_memory,
                "memory_usage_percent": memory_usage / max_memory if max_memory > 0 else 0
            }
        )

    except Exception as e:
        return HealthCheckResult(
            name="redis",
            status=HealthStatus.UNHEALTHY,
            response_time_ms=0,
            message=f"Redis connection failed: {str(e)}"
        )

# Initialize health checker
health_checker = HealthChecker()
health_checker.register_check("database", database_health_check)
health_checker.register_check("redis", redis_health_check)

# FastAPI endpoints
@app.get("/health")
async def health_endpoint():
    """Quick health check endpoint."""
    await health_checker.run_all_checks()
    status = health_checker.get_overall_status()

    return {
        "status": status.value,
        "timestamp": time.time()
    }

@app.get("/health/detailed")
async def detailed_health_endpoint():
    """Detailed health check endpoint."""
    await health_checker.run_all_checks()
    return health_checker.get_health_summary()
```

### ❌ Poor Observability Practices

```python
# Bad: No structured logging
def bad_logging():
    print("Something happened")  # No context, level, or structure
    logging.info(f"User {user_id} did something")  # String formatting, no structure

# Bad: No correlation IDs
async def bad_service_call():
    result = await external_service()  # No way to trace this call
    return result

# Bad: No metrics
async def bad_api_endpoint():
    # No tracking of performance, errors, or usage
    return await process_request()

# Bad: No error context
try:
    result = risky_operation()
except:
    logger.error("Something failed")  # No details about what or why
```

## Alerting Strategy

### Alert Levels
- **Critical**: Service down, data loss, security breach
- **Warning**: Performance degradation, high error rates
- **Info**: Capacity thresholds, maintenance events

### Key Alerts
- HTTP error rate > 5%
- Response time p95 > 2 seconds
- Database connection pool > 80% utilisation
- Circuit breaker trips
- Memory usage > 85%
- Disk space < 20%
